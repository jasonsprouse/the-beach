/**
 * PKP Agent: Redis Config Encryptor
 *
 * This agent uses Lit Protocol to encrypt Redis configuration credentials
 * for secure storage and sharing between The Beach and Y8 App.
 *
 * Use Case: Encrypt sensitive Redis Vercel KV credentials so they can be:
 * 1. Safely stored in version control (encrypted)
 * 2. Shared between team members
 * 3. Decrypted only by authorized PKP wallets
 * 4. Used in both The Beach and Y8 App environments
 */

import { LitNodeClient } from '@lit-protocol/lit-node-client';
import { LIT_NETWORK } from '@lit-protocol/constants';
import * as ethers from 'ethers';

interface RedisConfig {
  host: string;
  port: number;
  password: string;
  username: string;
  tls?: boolean;
  // Vercel KV specific
  kvRestApiUrl?: string;
  kvRestApiToken?: string;
  kvRestApiReadOnlyToken?: string;
}

interface EncryptionResult {
  ciphertext: string;
  dataToEncryptHash: string;
  accessControlConditions: any[];
  encryptedAt: string;
  network: string;
}

export class PKPRedisConfigEncryptor {
  private litNodeClient: LitNodeClient;
  private pkpPublicKey: string;
  private authSig: any;

  constructor(pkpPublicKey: string) {
    this.pkpPublicKey = pkpPublicKey;
    this.litNodeClient = new LitNodeClient({
      litNetwork: 'datil-test', // Use testnet for now
      debug: false,
    });
  }

  /**
   * Initialize the Lit Protocol client
   */
  async init() {
    await this.litNodeClient.connect();
    console.log('‚úÖ PKP Agent connected to Lit Network');
  }

  /**
   * Set authentication signature (from PKP wallet)
   */
  setAuthSig(authSig: any) {
    this.authSig = authSig;
  }

  /**
   * Encrypt Redis configuration
   * Only the specified PKP wallet can decrypt this data
   */
  async encryptRedisConfig(config: RedisConfig): Promise<EncryptionResult> {
    console.log('üîê PKP Agent: Encrypting Redis configuration...');

    // Convert config to JSON string
    const messageToEncrypt = JSON.stringify(config, null, 2);

    // Define access control: Only this PKP can decrypt
    const accessControlConditions = [
      {
        contractAddress: '',
        standardContractType: '',
        chain: 'ethereum' as const,
        method: '',
        parameters: [':userAddress'],
        returnValueTest: {
          comparator: '=',
          value: this.pkpPublicKey,
        },
      },
    ];

    // Encrypt the message
    const { ciphertext, dataToEncryptHash } = await this.litNodeClient.encrypt({
      accessControlConditions: accessControlConditions as any,
      dataToEncrypt: new TextEncoder().encode(messageToEncrypt),
    });

    const result: EncryptionResult = {
      ciphertext,
      dataToEncryptHash,
      accessControlConditions,
      encryptedAt: new Date().toISOString(),
      network: 'datil-test',
    };

    console.log('‚úÖ Redis config encrypted successfully!');
    console.log(`üì¶ Ciphertext length: ${ciphertext.length} characters`);
    console.log(`üîë Hash: ${dataToEncryptHash}`);

    return result;
  }

  /**
   * Decrypt Redis configuration
   * Requires valid PKP authentication
   */
  async decryptRedisConfig(
    encryptedData: EncryptionResult,
  ): Promise<RedisConfig> {
    console.log('üîì PKP Agent: Decrypting Redis configuration...');

    if (!this.authSig) {
      throw new Error('Authentication signature required for decryption');
    }

    // Decrypt the message
    const decryptedData = await this.litNodeClient.decrypt({
      accessControlConditions: encryptedData.accessControlConditions,
      ciphertext: encryptedData.ciphertext,
      dataToEncryptHash: encryptedData.dataToEncryptHash,
      authSig: this.authSig,
      chain: 'ethereum',
    });

    // Convert back to JSON
    const decryptedString = new TextDecoder().decode(
      decryptedData.decryptedData,
    );
    const config: RedisConfig = JSON.parse(decryptedString);

    console.log('‚úÖ Redis config decrypted successfully!');
    console.log(`üîå Host: ${config.host}`);

    return config;
  }

  /**
   * Generate Redis config for The Beach (NestJS)
   */
  generateBeachEnvVars(config: RedisConfig): string {
    return `
# Redis Configuration for The Beach
# Generated by PKP Agent on ${new Date().toISOString()}

# Standard Redis connection
REDIS_HOST=${config.host}
REDIS_PORT=${config.port}
REDIS_PASSWORD=${config.password}
REDIS_USERNAME=${config.username}
${config.tls ? 'REDIS_TLS=true' : ''}

# Vercel KV (alternative)
${config.kvRestApiUrl ? `KV_REST_API_URL=${config.kvRestApiUrl}` : ''}
${config.kvRestApiToken ? `KV_REST_API_TOKEN=${config.kvRestApiToken}` : ''}
${config.kvRestApiReadOnlyToken ? `KV_REST_API_READ_ONLY_TOKEN=${config.kvRestApiReadOnlyToken}` : ''}
`.trim();
  }

  /**
   * Generate Redis config for Y8 App (Next.js)
   */
  generateY8EnvVars(config: RedisConfig): string {
    return `
# Redis Configuration for Y8 App
# Generated by PKP Agent on ${new Date().toISOString()}

# Standard Redis connection
REDIS_HOST=${config.host}
REDIS_PORT=${config.port}
REDIS_PASSWORD=${config.password}
REDIS_USERNAME=${config.username}
${config.tls ? 'REDIS_TLS=true' : ''}

# Vercel KV (alternative)
${config.kvRestApiUrl ? `KV_REST_API_URL=${config.kvRestApiUrl}` : ''}
${config.kvRestApiToken ? `KV_REST_API_TOKEN=${config.kvRestApiToken}` : ''}
${config.kvRestApiReadOnlyToken ? `KV_REST_API_READ_ONLY_TOKEN=${config.kvRestApiReadOnlyToken}` : ''}
`.trim();
  }

  /**
   * Save encrypted config to file
   */
  async saveEncryptedConfig(
    encryptedData: EncryptionResult,
    filepath: string,
  ): Promise<void> {
    const fs = await import('fs/promises');
    await fs.writeFile(filepath, JSON.stringify(encryptedData, null, 2));
    console.log(`üíæ Encrypted config saved to: ${filepath}`);
  }

  /**
   * Load encrypted config from file
   */
  async loadEncryptedConfig(filepath: string): Promise<EncryptionResult> {
    const fs = await import('fs/promises');
    const data = await fs.readFile(filepath, 'utf-8');
    return JSON.parse(data);
  }

  /**
   * Disconnect from Lit Network
   */
  async disconnect() {
    await this.litNodeClient.disconnect();
    console.log('üîå PKP Agent disconnected');
  }
}

// ============================================================================
// Example Usage Script
// ============================================================================

async function main() {
  console.log('ü§ñ PKP Redis Config Encryptor Agent');
  console.log('====================================\n');

  // Step 1: Initialize PKP Agent
  const pkpPublicKey = process.env.PKP_PUBLIC_KEY || '0xYourPKPWalletAddress';
  const agent = new PKPRedisConfigEncryptor(pkpPublicKey);

  await agent.init();

  // Step 2: Define Redis configuration (REPLACE WITH REAL VALUES)
  const redisConfig: RedisConfig = {
    host: 'your-redis-host.upstash.io',
    port: 6379,
    password: 'your-super-secret-password',
    username: 'default',
    tls: true,
    // Vercel KV credentials
    kvRestApiUrl: 'https://your-kv-instance.upstash.io',
    kvRestApiToken: 'your-rest-api-token',
    kvRestApiReadOnlyToken: 'your-read-only-token',
  };

  // Step 3: Encrypt the configuration
  const encrypted = await agent.encryptRedisConfig(redisConfig);

  // Step 4: Save encrypted config
  await agent.saveEncryptedConfig(encrypted, './redis-config.encrypted.json');

  console.log('\nüìã Encrypted Redis Config:');
  console.log(JSON.stringify(encrypted, null, 2));

  // Step 5: Generate environment variable files
  console.log('\nüìÑ The Beach .env configuration:');
  console.log(agent.generateBeachEnvVars(redisConfig));

  console.log('\nüìÑ Y8 App .env.local configuration:');
  console.log(agent.generateY8EnvVars(redisConfig));

  // Step 6: Example of decryption (requires auth signature)
  console.log('\nüîì To decrypt later, use:');
  console.log('agent.setAuthSig(yourAuthSignature);');
  console.log('const config = await agent.decryptRedisConfig(encrypted);');

  await agent.disconnect();
}

// Uncomment to run:
// main().catch(console.error);

export default PKPRedisConfigEncryptor;
