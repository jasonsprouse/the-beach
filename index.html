<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-user VR Chat Room (Babylon.js - Refactored)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <script src="https://cdn.babylonjs.com/babylon.js" onerror="console.error('Failed to load Babylon.js')"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js" onerror="console.error('Failed to load Babylon.js loaders')"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js" onerror="console.error('Failed to load Babylon.js GUI')"></script>

    <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4" onerror="console.error('Failed to load Socket.IO')"></script>
    <script src="https://cdn.jsdelivr.net/npm/webrtc-adapter@8" onerror="console.error('Failed to load WebRTC adapter')"></script>
    <script src="/public/js/voice-control-addon.js" onerror="console.error('Failed to load voice control addon')"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        #renderCanvas {
            width: 100%;
            height: 100vh;
            display: block; /* Removes extra space below canvas */
            touch-action: none; /* Prevent browser gestures */
        }
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10; /* Ensure videos are above the scene */
        }
        .video-feed {
            width: 120px; /* Smaller video feeds */
            height: 90px;
            border: 2px solid #4CAF50; /* Green border */
            border-radius: 8px;
            margin: 5px;
            object-fit: cover; /* Ensure video fills the container */
            background-color: #000; /* Black background for video */
            transform: scaleX(-1); /* Mirror local video */
        }
        .video-feed.local {
            border-color: #00B0FF; /* Blue border for local video */
        }
        #debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.8em;
        }
        
        /* XR Loading Overlay */
        .xr-loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.8s ease-out, transform 0.8s ease-out;
        }
        
        .xr-loading-overlay.hidden {
            opacity: 0;
            transform: scale(1.1);
            pointer-events: none;
        }
        
        .welcome-content {
            text-align: center;
            color: white;
            max-width: 600px;
            padding: 2rem;
        }
        
        .welcome-icon {
            font-size: 5rem;
            margin-bottom: 2rem;
            animation: welcome-float 3s ease-in-out infinite;
        }
        
        @keyframes welcome-float {
            0%, 100% {
                transform: translateY(0px) rotate(0deg);
            }
            50% {
                transform: translateY(-15px) rotate(2deg);
            }
        }
        
        .welcome-title {
            font-size: 3rem;
            font-weight: 800;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #4ECDC4, #44A08D);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .welcome-subtitle {
            font-size: 1.5rem;
            margin-bottom: 2rem;
            opacity: 0.9;
        }
        
        .xr-progress-container {
            width: 400px;
            margin: 2rem 0;
        }
        
        .xr-progress-bar {
            width: 100%;
            height: 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 1rem;
        }
        
        .xr-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ECDC4, #44A08D);
            border-radius: 6px;
            width: 0%;
            transition: width 0.3s ease;
            animation: progress-shimmer 2s infinite;
        }
        
        @keyframes progress-shimmer {
            0% {
                background-position: -400px 0;
            }
            100% {
                background-position: 400px 0;
            }
        }
        
        .xr-progress-fill {
            background: linear-gradient(90deg, #4ECDC4, #ffffff, #44A08D);
            background-size: 400px 100%;
        }
        
        .xr-status {
            font-size: 1.2rem;
            opacity: 0.8;
        }
        
        .feature-highlights {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 2rem;
        }
        
        .feature-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        
        .feature-emoji {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }
        
        .feature-text {
            font-size: 0.9rem;
            opacity: 0.9;
        }
    </style>
</head>
<body class="bg-gray-900">
    <!-- XR Loading Overlay -->
    <div id="xrLoadingOverlay" class="xr-loading-overlay">
        <div class="welcome-content">
            <div class="welcome-icon">üèùÔ∏è</div>
            <h1 class="welcome-title">Welcome to Paradise</h1>
            <p class="welcome-subtitle">Your tropical XR experience is loading...</p>
            
            <div class="xr-progress-container">
                <div class="xr-progress-bar">
                    <div id="xrProgressFill" class="xr-progress-fill"></div>
                </div>
                <div id="xrStatus" class="xr-status">Initializing XR environment...</div>
            </div>
            
            <div class="feature-highlights">
                <div class="feature-item">
                    <div class="feature-emoji">üé§</div>
                    <div class="feature-text">Voice Control</div>
                </div>
                <div class="feature-item">
                    <div class="feature-emoji">ü•Ω</div>
                    <div class="feature-text">VR Ready</div>
                </div>
                <div class="feature-item">
                    <div class="feature-emoji">üë•</div>
                    <div class="feature-text">Multiplayer</div>
                </div>
                <div class="feature-item">
                    <div class="feature-emoji">üåä</div>
                    <div class="feature-text">Real-time</div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="renderCanvas"></canvas>
    <div id="video-container">
        <video id="local-video" class="video-feed local" autoplay muted playsinline></video>
    </div>
    <div id="debug-info">
        <p>User ID: <span id="user-id">Loading...</span></p>
        <p>Room: <span id="room-id">Loading...</span></p>
        <p>Peers: <span id="peer-count">0</span></p>
        <p>XR Session: <span id="xr-session-status">Not Started</span></p>
        <p>Position: <span id="position-info">X:0 Y:0 Z:0</span></p>
    </div>

    <script>
        // --- Global State & Elements ---
        // Encapsulate state where possible, but some globals are convenient here
        const canvas = document.getElementById('renderCanvas');
        const localVideo = document.getElementById('local-video');
        const videoContainer = document.getElementById('video-container');
        const debugElements = {
            userId: document.getElementById('user-id'),
            roomId: document.getElementById('room-id'),
            peerCount: document.getElementById('peer-count'),
            xrStatus: document.getElementById('xr-session-status'),
            positionInfo: document.getElementById('position-info')
        };

        let engine, scene, camera, xrHelper, socket, localStream;
        let userId, roomId;
        const peerConnections = new Map();
        const peerVideos = new Map();
        const peerAvatars = new Map();
        const inputMap = {}; // Stores pressed keys

        // --- 1. Engine and Scene Setup ---
        function initializeBabylonEngine(canvas) {
            console.log("Initializing Babylon Engine...");
            
            // Ensure canvas has proper dimensions before creating engine
            if (!canvas) {
                throw new Error("Canvas element not found");
            }
            
            // Wait for DOM to be ready and canvas to be rendered
            const ensureCanvasReady = () => {
                return new Promise((resolve) => {
                    const checkCanvas = () => {
                        const rect = canvas.getBoundingClientRect();
                        if (rect.width > 0 && rect.height > 0) {
                            resolve();
                        } else {
                            // Set explicit dimensions if not available
                            canvas.setAttribute('width', window.innerWidth || 1920);
                            canvas.setAttribute('height', window.innerHeight || 1080);
                            canvas.style.width = '100%';
                            canvas.style.height = '100vh';
                            requestAnimationFrame(checkCanvas);
                        }
                    };
                    checkCanvas();
                });
            };
            
            return ensureCanvasReady().then(() => {
                // Force canvas to have minimum dimensions
                const rect = canvas.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) {
                    console.log("Canvas has zero dimensions, setting default size...");
                    // Use setAttribute to avoid read-only property errors
                    canvas.setAttribute('width', window.innerWidth);
                    canvas.setAttribute('height', window.innerHeight);
                    canvas.style.width = '100%';
                    canvas.style.height = '100vh';
                }
                
                // Log canvas dimensions for debugging
                console.log(`Canvas dimensions: ${canvas.getAttribute('width') || canvas.width}x${canvas.getAttribute('height') || canvas.height}`);
                console.log(`Canvas client size: ${canvas.clientWidth}x${canvas.clientHeight}`);
                
                // Create engine with error handling
                let engine;
                try {
                    engine = new BABYLON.Engine(canvas, true, { 
                        preserveDrawingBuffer: true, 
                        stencil: true,
                        antialias: true,
                        failIfMajorPerformanceCaveat: false
                    });
                    
                    // Add resize handler with debouncing
                    let resizeTimeout;
                    window.addEventListener('resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                            if (engine && !engine.isDisposed) {
                                engine.resize();
                            }
                        }, 100);
                    });
                    
                    console.log("Engine Initialized successfully.");
                    return engine;
                } catch (error) {
                    console.error("Failed to create Babylon.js engine:", error);
                    throw new Error(`Engine creation failed: ${error.message}`);
                }
            });
        }

        async function createBabylonScene(engine, canvas, xrStatusEl) {
            console.log("Creating Babylon Scene...");
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.53, 0.81, 0.92); // Sky blue
            scene.gravity = new BABYLON.Vector3(0, -0.981, 0); // Standard gravity
            scene.collisionsEnabled = true; // Enable collisions globally

            // --- Camera (Non-VR Fallback) ---
            camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, 1.6, -5), scene);
            camera.attachControl(canvas, true);
            camera.speed = 0.2;
            camera.angularSensibility = 4000;
            camera.minZ = 0.1;
            camera.ellipsoid = new BABYLON.Vector3(0.5, 0.8, 0.5); // Collision avatar size
            camera.checkCollisions = true;
            camera.applyGravity = true;

            // --- Lighting ---
            const light = new BABYLON.HemisphericLight("hemiLight", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.8;
            const dirLight = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-1, -2, -1), scene);
            dirLight.position = new BABYLON.Vector3(20, 40, 20);
            dirLight.intensity = 0.7;

            // --- Shadows ---
            const shadowGenerator = new BABYLON.ShadowGenerator(1024, dirLight);
            shadowGenerator.useBlurExponentialShadowMap = true;
            shadowGenerator.blurKernel = 32;

            // --- Room Geometry ---
            createRoomGeometry(scene, shadowGenerator);

            // --- WebXR Setup ---
            xrHelper = await setupWebXR(scene, xrStatusEl, camera);

             // --- Input Handling ---
            setupInputHandling(scene, inputMap);

            // --- Voice Control Setup ---
            if (typeof VoiceEnvironmentModifier !== 'undefined') {
                window.voiceModifier = new VoiceEnvironmentModifier(scene);
                addVoiceControlUI();
                console.log('üé§ Voice control initialized');
            }

            console.log("Scene Created.");
            return { scene, camera, xrHelper }; // Return created objects
        }

        function createRoomGeometry(scene, shadowGenerator) {
            const roomSize = 20;
            const wallHeight = 3;
            const wallThickness = 0.2;

            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: roomSize, height: roomSize }, scene);
            ground.checkCollisions = true;
            const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.56, 0.74, 0.56);
            ground.material = groundMat;
            ground.receiveShadows = true;

            // Walls
            const wallMat = new BABYLON.StandardMaterial("wallMat", scene);
            wallMat.diffuseColor = new BABYLON.Color3(0.75, 0.75, 0.75);

            const walls = [
                { name: "N", w: roomSize, d: wallThickness, x: 0, z: roomSize / 2 - wallThickness / 2 },
                { name: "S", w: roomSize, d: wallThickness, x: 0, z: -roomSize / 2 + wallThickness / 2 },
                { name: "E", w: wallThickness, d: roomSize, x: roomSize / 2 - wallThickness / 2, z: 0 },
                { name: "W", w: wallThickness, d: roomSize, x: -roomSize / 2 + wallThickness / 2, z: 0 }
            ];

            walls.forEach(w => {
                const wall = BABYLON.MeshBuilder.CreateBox(`wall${w.name}`, { width: w.w, height: wallHeight, depth: w.d }, scene);
                wall.position = new BABYLON.Vector3(w.x, wallHeight / 2, w.z);
                wall.material = wallMat;
                wall.checkCollisions = true;
                shadowGenerator.addShadowCaster(wall);
                wall.receiveShadows = true; // Walls can receive shadows too
            });
        }

        async function setupWebXR(scene, xrStatusEl, fallbackCamera) {
            console.log("Setting up WebXR...");
            try {
                const xr = await scene.createDefaultXRExperienceAsync({
                    floorMeshes: [scene.getMeshByName("ground")],
                });

                xr.onStateChangedObservable.add((state) => {
                    xrStatusEl.textContent = BABYLON.WebXRState[state];
                    switch (state) {
                        case BABYLON.WebXRState.IN_XR:
                            console.log("Entered XR");
                            camera = xr.baseExperience.camera; // Update global camera reference
                            break;
                        case BABYLON.WebXRState.NOT_IN_XR:
                            console.log("Exited XR");
                            camera = fallbackCamera; // Revert to fallback camera
                            if (camera) scene.activeCamera = camera;
                            break;
                    }
                });

                if (!xr.baseExperience) {
                    console.log("WebXR not supported.");
                    xrStatusEl.textContent = "Not Supported";
                    return null;
                } else {
                     xrStatusEl.textContent = "Ready";
                     console.log("WebXR Ready.");
                     return xr; // Return the helper
                }
            } catch (error) {
                console.error("Error initializing WebXR:", error);
                xrStatusEl.textContent = "Init Error";
                return null;
            }
        }

        // --- 2. Input Handling ---
        function setupInputHandling(scene, inputMap) {
            console.log("Setting up Input Handling...");
            scene.actionManager = new BABYLON.ActionManager(scene);
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, (evt) => {
                inputMap[evt.sourceEvent.key.toLowerCase()] = true;
            }));
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, (evt) => {
                inputMap[evt.sourceEvent.key.toLowerCase()] = false;
            }));
            console.log("Input Handling Ready.");
        }

        function handleNonVRMovement(camera, inputMap, engine) {
            if (!camera || !(camera instanceof BABYLON.FreeCamera)) return; // Only move FreeCamera

            const moveSpeed = camera.speed * engine.getDeltaTime() / 16; // Frame-rate independent speed
            let velocity = BABYLON.Vector3.Zero(); // Use camera's local space for movement

            if (inputMap["w"] || inputMap["arrowup"]) {
                velocity.z += 1;
            }
            if (inputMap["s"] || inputMap["arrowdown"]) {
                velocity.z -= 1;
            }
            if (inputMap["a"] || inputMap["arrowleft"]) {
                 velocity.x -= 1;
            }
            if (inputMap["d"] || inputMap["arrowright"]) {
                 velocity.x += 1;
            }

            // Normalize velocity if moving diagonally and apply speed
            if (velocity.length() > 0.1) {
                 velocity.normalize().scaleInPlace(moveSpeed);
                 // Transform velocity to world space based on camera rotation
                 const worldVelocity = BABYLON.Vector3.TransformNormal(velocity, camera.getWorldMatrix());
                 // Apply movement directly to position (gravity/collisions handled by engine)
                 camera.cameraDirection.addInPlace(worldVelocity);
            }

            // Handle vertical movement separately (not affected by camera direction)
             if (inputMap["e"]) { // Move Up (respecting collisions)
                camera.position.y += moveSpeed;
            }
            if (inputMap["q"]) { // Move Down (respecting collisions)
                camera.position.y -= moveSpeed;
            }
        }


        // --- 3. WebRTC Setup ---
        async function setupWebRTC(localVideoElement) {
            console.log("Setting up WebRTC...");
            
            // Check if media devices are available
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.warn("WebRTC not supported in this browser");
                return null;
            }
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'user', 
                        width: { ideal: 160, max: 320 }, 
                        height: { ideal: 120, max: 240 }
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                
                if (localVideoElement) {
                    localVideoElement.srcObject = stream;
                    
                    // Handle video element errors
                    localVideoElement.onerror = (event) => {
                        console.error("Video element error:", event);
                    };
                    
                    localVideoElement.onloadedmetadata = () => {
                        console.log("Video metadata loaded successfully");
                    };
                }
                
                console.log("WebRTC Media Stream acquired successfully.");
                return stream;
            } catch (error) {
                console.error("Error accessing media devices:", error);
                
                // Provide specific error messages
                let errorMessage = "Could not access camera/microphone.";
                if (error.name === 'NotAllowedError') {
                    errorMessage = "Camera/microphone access denied. Please allow permissions and refresh.";
                } else if (error.name === 'NotFoundError') {
                    errorMessage = "No camera/microphone found. Video chat will be disabled.";
                } else if (error.name === 'NotReadableError') {
                    errorMessage = "Camera/microphone is busy or unavailable.";
                } else if (error.name === 'OverconstrainedError') {
                    errorMessage = "Camera/microphone constraints not supported.";
                }
                
                console.warn(errorMessage);
                // Don't show alert immediately, let the app continue
                return null;
            }
        }

        // --- 4. Socket.IO Setup ---
        function setupSocketIO(debugElements) {
            console.log("Setting up Socket.IO...");
            const socket = io('http://localhost:3000'); // Connect

            socketInstance.on('connect', () => {
                userId = socketInstance.id;
                debugElements.userId.textContent = userId;
                console.log('Connected to server with ID:', userId);
                // Join room *after* connection is established
                socketInstance.emit('join-room', 'babylon-vr-room');
            });

            socketInstance.on('joined-room', (joinedRoomId) => {
                roomId = joinedRoomId;
                debugElements.roomId.textContent = roomId;
                console.log(`Joined room: ${roomId}`);
            });

            socketInstance.on('disconnect', () => {
                console.log('Disconnected from server.');
                 // Handle cleanup if needed
                 debugElements.userId.textContent = 'Disconnected';
                 debugElements.roomId.textContent = 'N/A';
            });

            socketInstance.on('connect_error', (error) => {
                console.error('Socket connection error:', error);
                alert('Could not connect to the signaling server.');
            });

            console.log("Socket.IO Initialized.");
            return socketInstance;
        }

        // --- 5. WebRTC Signaling (Depends on Socket.IO and WebRTC) ---
        function setupWebRTCSignaling(socket, localStream, peerConnections, peerVideos, videoContainer, peerAvatars, scene, debugElements) {
            if (!socket || !localStream) {
                console.error("Cannot setup signaling without socket or local stream.");
                return;
            }
            console.log("Setting up WebRTC Signaling Listeners...");

            socket.on('user-joined', async (newPeerId) => {
                if (newPeerId === userId) return;
                console.log(`User ${newPeerId} joined`);

                const pc = createPeerConnection(newPeerId, localStream, peerConnections, peerVideos, videoContainer, debugElements);
                if (!pc) return;

                createPeerAvatar(newPeerId, scene, peerAvatars); // Create 3D avatar

                try {
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    socket.emit('offer', { to: newPeerId, offer });
                    console.log(`Sent offer to ${newPeerId}`);
                } catch (error) {
                    console.error(`Error creating offer for ${newPeerId}:`, error);
                }
            });

            socket.on('offer', async (data) => {
                const { offer, from: peerId } = data;
                console.log(`Received offer from ${peerId}`);
                let pc = peerConnections.get(peerId);
                if (!pc) {
                    pc = createPeerConnection(peerId, localStream, peerConnections, peerVideos, videoContainer, debugElements);
                    if (!pc) return;
                    createPeerAvatar(peerId, scene, peerAvatars); // Ensure avatar exists if connection initiated by remote
                }
                await handleOffer(offer, peerId, pc, socket);
            });

            socket.on('answer', async(data) => {
                const { answer, from: peerId } = data;
                console.log(`Received answer from ${peerId}`);
                await handleAnswer(answer, peerId, peerConnections);
            });

            socket.on('ice-candidate', async (data) => {
                const { candidate, from: peerId } = data;
                await handleIceCandidate(candidate, peerId, peerConnections);
            });

            socket.on('user-disconnected', (disconnectedPeerId) => {
                if (disconnectedPeerId === userId) return;
                console.log(`User ${disconnectedPeerId} disconnected`);
                cleanupPeerConnection(disconnectedPeerId, peerConnections, peerVideos, peerAvatars, debugElements);
            });

            // Listen for movement updates for other users
            socket.on('move', (data) => {
                if (data.userId === userId || !scene) return;
                updatePeerAvatar(data.userId, data.position, data.rotation, peerAvatars);
            });

            console.log("WebRTC Signaling Ready.");
        }

        function createPeerConnection(peerId, localStream, peerConnections, peerVideos, videoContainer, debugElements) {
            console.log(`Creating peer connection for ${peerId}`);
            const pc = new RTCPeerConnection({
                iceServers: [ { urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' } ],
            });

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice-candidate', { to: peerId, candidate: event.candidate });
                }
            };

            pc.ontrack = (event) => {
                console.log(`Track received from ${peerId}`);
                let video = peerVideos.get(peerId);
                if (!video) {
                    video = document.createElement('video');
                    video.classList.add('video-feed');
                    video.autoplay = true;
                    video.playsinline = true;
                    video.dataset.peerId = peerId;
                    videoContainer.appendChild(video);
                    peerVideos.set(peerId, video);
                }
                if (event.streams && event.streams[0]) {
                     video.srcObject = event.streams[0];
                } else {
                    let inboundStream = new MediaStream([event.track]);
                    video.srcObject = inboundStream;
                }
            };

            pc.oniceconnectionstatechange = () => {
                console.log(`ICE state for ${peerId}: ${pc.iceConnectionState}`);
                if (pc.iceConnectionState === 'failed' || pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'closed') {
                    console.warn(`Peer connection for ${peerId} failed or closed.`);
                    // Consider cleanup here as well, although user-disconnected event is primary
                    // cleanupPeerConnection(peerId, peerConnections, peerVideos, peerAvatars, debugElements);
                }
            };

             // Add local tracks
            localStream.getTracks().forEach((track) => {
                try {
                    pc.addTrack(track, localStream);
                } catch (error) {
                    console.error(`Error adding track for ${peerId}:`, error);
                }
            });

            peerConnections.set(peerId, pc);
            updatePeerCount(peerConnections.size, debugElements.peerCount);
            return pc;
        }

        async function handleOffer(offer, peerId, pc, socket) {
             try {
                await pc.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                socket.emit('answer', { to: peerId, answer });
                console.log(`Sent answer to ${peerId}`);
            } catch (error) {
                console.error(`Error handling offer from ${peerId}:`, error);
            }
        }

        async function handleAnswer(answer, peerId, peerConnections) {
            const pc = peerConnections.get(peerId);
            if (!pc) return console.error(`No peer connection for ${peerId} to handle answer`);
            try {
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
                console.log(`Remote description set for ${peerId}`);
            } catch (error) {
                 console.error(`Error handling answer from ${peerId}:`, error);
            }
        }

        async function handleIceCandidate(candidate, peerId, peerConnections) {
            const pc = peerConnections.get(peerId);
            if (!pc) return console.error(`No peer connection for ${peerId} to handle candidate`);
             try {
                 if (candidate) {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                 }
            } catch (error) {
                 console.error(`Error adding ICE candidate from ${peerId}:`, error);
            }
        }

        function cleanupPeerConnection(peerId, peerConnections, peerVideos, peerAvatars, debugElements) {
            // Close and remove PeerConnection
            const pc = peerConnections.get(peerId);
            if (pc) {
                pc.close();
                peerConnections.delete(peerId);
            }
            // Remove video element
            const video = peerVideos.get(peerId);
            if (video) {
                video.srcObject = null;
                video.remove();
                peerVideos.delete(peerId);
            }
            // Remove 3D avatar
            removePeerAvatar(peerId, peerAvatars);
            // Update UI
            updatePeerCount(peerConnections.size, debugElements.peerCount);
        }

        function updatePeerCount(count, peerCountEl) {
            peerCountEl.textContent = count;
        }


        // --- 6. Avatar Management ---
        function createPeerAvatar(peerId, scene, peerAvatars) {
            if (!scene || peerAvatars.has(peerId)) return;
            console.log(`Creating avatar for ${peerId}`);

            const avatar = BABYLON.MeshBuilder.CreateCapsule(`avatar_${peerId}`, { height: 1.6, radius: 0.3 }, scene);
            avatar.position = new BABYLON.Vector3(0, -100, 0); // Start off-screen, wait for first move event
            avatar.rotationQuaternion = new BABYLON.Quaternion();
            avatar.checkCollisions = true; // Enable collisions for avatars if desired
            avatar.ellipsoid = new BABYLON.Vector3(0.3, 0.8, 0.3); // Collision shape for avatar

            const avatarMat = new BABYLON.StandardMaterial(`avatarMat_${peerId}`, scene);
            avatarMat.diffuseColor = BABYLON.Color3.Random();
            avatarMat.alpha = 0.8;
            avatar.material = avatarMat;

            const head = BABYLON.MeshBuilder.CreateSphere(`head_${peerId}`, { diameter: 0.4 }, scene);
            head.parent = avatar;
            head.position.y = 0.8;
            const headMat = new BABYLON.StandardMaterial(`headMat_${peerId}`, scene);
            headMat.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
            head.material = headMat;

            peerAvatars.set(peerId, avatar);
        }

        function removePeerAvatar(peerId, peerAvatars) {
            const avatar = peerAvatars.get(peerId);
            if (avatar) {
                console.log(`Removing avatar for ${peerId}`);
                avatar.dispose(false, true);
                peerAvatars.delete(peerId);
            }
        }

        function updatePeerAvatar(peerId, positionData, rotationData, peerAvatars) {
            const avatar = peerAvatars.get(peerId);
            if (avatar) {
                const targetPosition = new BABYLON.Vector3(positionData.x, positionData.y, positionData.z);
                const targetRotation = new BABYLON.Quaternion(rotationData.x, rotationData.y, rotationData.z, rotationData.w);

                // Use interpolation for smoother visual updates
                avatar.position = BABYLON.Vector3.Lerp(avatar.position, targetPosition, 0.15);
                avatar.rotationQuaternion = BABYLON.Quaternion.Slerp(avatar.rotationQuaternion, targetRotation, 0.15);
            }
             // else { console.warn(`Avatar not found for update: ${peerId}`); } // Avatar might not be created yet
        }

        // --- 7. Render Loop and Position Emission ---
        function startRenderLoop(engine, scene, socket, debugElements) {
            console.log("Starting Render Loop...");
            let lastEmitTime = 0;
            const emitInterval = 100; // ms

            engine.runRenderLoop(() => {
                if (!scene || !camera) return; // Wait until scene/camera are ready

                // Handle non-VR movement based on inputMap
                 if (xrHelper && xrHelper.state === BABYLON.WebXRState.NOT_IN_XR) {
                    handleNonVRMovement(camera, inputMap, engine);
                 }

                // Emit position periodically
                const now = performance.now();
                if (socket && socket.connected && userId && now - lastEmitTime > emitInterval) {
                    lastEmitTime = now;
                    emitPositionUpdate(socket, camera, xrHelper, userId, debugElements.positionInfo);
                }

                scene.render();
            });
            console.log("Render Loop Started.");
        }

        function emitPositionUpdate(socket, currentCamera, xrHelper, userId, positionInfoEl) {
            let pos, rot;

            if (xrHelper && xrHelper.state === BABYLON.WebXRState.IN_XR) {
                pos = xrHelper.baseExperience.camera.globalPosition;
                rot = xrHelper.baseExperience.camera.rotationQuaternion;
            } else if (currentCamera) { // Use the active non-VR camera
                pos = currentCamera.globalPosition;
                // Ensure quaternion exists and is updated for FreeCamera
                if (!currentCamera.rotationQuaternion) {
                    currentCamera.rotationQuaternion = BABYLON.Quaternion.FromEulerVector(currentCamera.rotation);
                } else {
                    BABYLON.Quaternion.FromEulerVectorToRef(currentCamera.rotation, currentCamera.rotationQuaternion);
                }
                rot = currentCamera.rotationQuaternion;
            }

            if (pos && rot) {
                 socket.emit('move', {
                    userId: userId,
                    position: { x: pos.x, y: pos.y, z: pos.z },
                    rotation: { x: rot.x, y: rot.y, z: rot.z, w: rot.w }
                });
                // Update debug info
                positionInfoEl.textContent = `X:${pos.x.toFixed(2)} Y:${pos.y.toFixed(2)} Z:${pos.z.toFixed(2)}`;
            }
        }


        // --- 8. Main Application Initialization ---
        let initializationAbortController = null;
        
        async function main() {
            console.log("Starting Application Initialization...");
            
            // Create abort controller for this initialization
            initializationAbortController = new AbortController();
            const signal = initializationAbortController.signal;
            
            // Start XR loading progress
            startXRLoadingProgress();
            
            try {
                // Check for abort before each step
                if (signal.aborted) throw new Error("Initialization aborted");
                
                updateXRProgress(20, "Initializing Babylon.js engine...");
                // Initialize core components with validation
                if (!canvas) {
                    throw new Error("Canvas element not found");
                }
                engine = await initializeBabylonEngine(canvas);
                
                if (signal.aborted) throw new Error("Initialization aborted");
                
                updateXRProgress(40, "Setting up WebRTC media...");
                // WebRTC setup with timeout and error handling
                try {
                    localStream = await Promise.race([
                        setupWebRTC(localVideo),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error("WebRTC setup timeout")), 10000)
                        )
                    ]);
                } catch (webrtcError) {
                    console.warn("WebRTC setup failed, continuing without video:", webrtcError);
                    localStream = null; // Continue without video
                }

                if (signal.aborted) throw new Error("Initialization aborted");
                
                updateXRProgress(60, "Creating XR environment...");
                // Create scene (which includes XR setup)
                const sceneResult = await createBabylonScene(engine, canvas, debugElements.xrStatus);
                scene = sceneResult.scene;
                // camera and xrHelper are now globally assigned within createBabylonScene/setupWebXR

                if (signal.aborted) throw new Error("Initialization aborted");
                
                updateXRProgress(75, "Connecting to multiplayer server...");
                // Initialize networking *after* core components are ready
                socket = setupSocketIO(debugElements);

                if (signal.aborted) throw new Error("Initialization aborted");
                
                updateXRProgress(85, "Initializing voice controls...");
                // Setup signaling listeners (needs socket and localStream)
                if (localStream) {
                     setupWebRTCSignaling(socket, localStream, peerConnections, peerVideos, videoContainer, peerAvatars, scene, debugElements);
                } else {
                    console.warn("Local stream not available, WebRTC signaling disabled.");
                    // Don't show alert, just continue
                }

                if (signal.aborted) throw new Error("Initialization aborted");
                
                updateXRProgress(95, "Starting render loop...");
                // Start the rendering loop
                startRenderLoop(engine, scene, socket, debugElements);

                updateXRProgress(100, "üèùÔ∏è Welcome to Paradise!");
                
                // Hide loading overlay after a brief pause
                setTimeout(() => {
                    if (!signal.aborted) {
                        hideXRLoadingOverlay();
                    }
                }, 1000);

                console.log("Application Initialization Complete.");

            } catch (error) {
                console.error("Initialization failed:", error);
                
                // Clean up on error
                if (engine && !engine.isDisposed) {
                    engine.dispose();
                }
                
                if (error.message === "Initialization aborted") {
                    console.log("Initialization was aborted");
                    return;
                }
                
                updateXRProgress(0, "‚ùå Initialization failed: " + error.message);
                setTimeout(() => {
                    hideXRLoadingOverlay();
                    // Show user-friendly error message
                    const errorMsg = error.message.includes("Canvas") ? 
                        "Graphics initialization failed. Please refresh the page." :
                        "Failed to load the application. Please refresh and try again.";
                    alert(errorMsg);
                }, 2000);
            } finally {
                // Clean up abort controller
                initializationAbortController = null;
            }
        }

        // --- Start the application ---
        
        // Global error handlers
        window.addEventListener('error', (event) => {
            console.error('Global error caught:', event.error);
            // Prevent script errors from breaking the app
            if (event.error && event.error.message === 'Script error.') {
                event.preventDefault();
                return true;
            }
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            
            // Handle common abort errors gracefully
            if (event.reason && event.reason.name === 'AbortError') {
                console.log('Ignoring AbortError from cancelled operation');
                event.preventDefault();
                return;
            }
            
            // Handle canvas-related errors
            if (event.reason && event.reason.message && 
                (event.reason.message.includes('getImageData') || 
                 event.reason.message.includes('width is 0') ||
                 event.reason.message.includes('Cannot set property id'))) {
                console.log('Ignoring canvas/DOM error:', event.reason.message);
                event.preventDefault();
                return;
            }
            
            // Handle script loading errors
            if (event.reason && event.reason.message && 
                event.reason.message.includes('Loading CSS chunk')) {
                console.log('Ignoring CSS chunk loading error');
                event.preventDefault();
                return;
            }
        });

        // Ensure DOM is loaded before starting
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', main);
        } else {
            main();
        }

        // XR Loading Progress Functions
        function startXRLoadingProgress() {
            const overlay = document.getElementById('xrLoadingOverlay');
            const progressFill = document.getElementById('xrProgressFill');
            const status = document.getElementById('xrStatus');
            
            // Ensure overlay is visible
            overlay.classList.remove('hidden');
            progressFill.style.width = '0%';
            status.textContent = 'Initializing XR environment...';
        }
        
        function updateXRProgress(percentage, statusText) {
            const progressFill = document.getElementById('xrProgressFill');
            const status = document.getElementById('xrStatus');
            
            progressFill.style.width = percentage + '%';
            status.textContent = statusText;
            
            console.log(`XR Loading: ${percentage}% - ${statusText}`);
        }
        
        function hideXRLoadingOverlay() {
            const overlay = document.getElementById('xrLoadingOverlay');
            overlay.classList.add('hidden');
            
            // Remove completely after transition
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 800);
        }

    </script>
</body>
</html>
